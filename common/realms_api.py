# generated by https://app.quicktype.io/
import contextlib
import typing
from enum import Enum
from typing import Any
from typing import Callable
from typing import cast
from typing import List
from typing import Optional
from typing import Type
from typing import TypeVar

import aiohttp
import attrs
import orjson
from xbox.webapi.authentication.manager import AuthenticationManager

import common.utils as utils

T = TypeVar("T")


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    return [f(y) for y in x]


class DefaultPermission(Enum):
    MEMBER = "MEMBER"
    VISITOR = "VISITOR"


class State(Enum):
    CLOSED = "CLOSED"
    OPEN = "OPEN"


class WorldType(Enum):
    NORMAL = "NORMAL"


@attrs.define()
class Realm:
    id: int
    remote_subscription_id: str
    owner: str
    owner_uuid: str
    name: str
    default_permission: DefaultPermission
    state: State
    days_left: int
    expired: bool
    expired_trial: bool
    grace_period: bool
    world_type: WorldType
    players: None
    max_players: int
    minigame_name: None
    minigame_id: None
    minigame_image: None
    active_slot: int
    slots: None
    member: bool
    club_id: int
    subscription_refresh_status: None
    motd: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Realm":  # sourcery skip: avoid-builtin-shadow
        id = obj.get("id")
        remote_subscription_id = obj.get("remoteSubscriptionId")
        owner = obj.get("owner")
        owner_uuid = obj.get("ownerUUID")
        name = obj.get("name")
        default_permission = DefaultPermission(obj.get("defaultPermission"))
        state = State(obj.get("state"))
        days_left = obj.get("daysLeft")
        expired = obj.get("expired")
        expired_trial = obj.get("expiredTrial")
        grace_period = obj.get("gracePeriod")
        world_type = WorldType(obj.get("worldType"))
        players = obj.get("players")
        max_players = obj.get("maxPlayers")
        minigame_name = obj.get("minigameName")
        minigame_id = obj.get("minigameId")
        minigame_image = obj.get("minigameImage")
        active_slot = obj.get("activeSlot")
        slots = obj.get("slots")
        member = obj.get("member")
        club_id = obj.get("clubId")
        subscription_refresh_status = obj.get("subscriptionRefreshStatus")
        motd = obj.get("motd")
        return Realm(
            id,
            remote_subscription_id,
            owner,
            owner_uuid,
            name,
            default_permission,
            state,
            days_left,
            expired,
            expired_trial,
            grace_period,
            world_type,
            players,
            max_players,
            minigame_name,
            minigame_id,
            minigame_image,
            active_slot,
            slots,
            member,
            club_id,
            subscription_refresh_status,
            motd,
        )


@attrs.define()
class Worlds:
    servers: List[Realm]

    @staticmethod
    def from_dict(obj: Any) -> "Worlds":
        servers = from_list(Realm.from_dict, obj.get("servers"))
        return Worlds(servers)


class RealmsAPIException(Exception):
    def __init__(self, resp: aiohttp.ClientResponse, error: Exception):
        self.resp = resp
        self.error = error

        super().__init__(
            "An error occured when trying to access this resource: code"
            f" {resp.status}.\nError: {error}"
        )


@attrs.define()
class RealmsAPI:
    session: aiohttp.ClientSession = attrs.field()
    auth_mgr: AuthenticationManager = attrs.field()
    HEADERS: dict = attrs.field(init=False, factory=dict)

    def __attrs_post_init__(self):
        self.HEADERS = {
            "Client-Version": utils.MC_VERSION,
            "User-Agent": "MCPE/UWP",
            "Authorization": self.auth_mgr.xsts_token.authorization_header_value,
        }

    async def request(self, method: str, url: str, data: typing.Optional[dict] = None):
        async with self.session.request(
            method, f"{utils.REALMS_API_URL}{url}", headers=self.HEADERS, data=data
        ) as resp:
            try:
                resp.raise_for_status()
                return await resp.json(loads=orjson.loads)
            except Exception as e:
                raise RealmsAPIException(resp, e)

    async def get(self, url: str, data: typing.Optional[dict] = None):
        return await self.request("GET", url, data=data)

    async def post(self, url: str, data: typing.Optional[dict] = None):
        return await self.request("POST", url, data=data)

    async def join_realm_from_code(self, code: str):
        return Realm.from_dict(await self.post(f"invites/v1/link/accept/{code}"))

    async def fetch_realms(self):
        return Worlds.from_dict(await self.get("worlds"))
