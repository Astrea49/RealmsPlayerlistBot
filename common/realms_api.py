# realms api classes generated by https://app.quicktype.io/
import asyncio
import os
import typing
from enum import Enum
from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import TypeVar

import aiohttp
import attrs
import orjson
from xbox.webapi.authentication.manager import AuthenticationManager
from xbox.webapi.authentication.models import OAuth2TokenResponse

import common.utils as utils

T = TypeVar("T")


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    return [f(y) for y in x]


class DefaultPermission(Enum):
    MEMBER = "MEMBER"
    VISITOR = "VISITOR"


class State(Enum):
    CLOSED = "CLOSED"
    OPEN = "OPEN"


class WorldType(Enum):
    NORMAL = "NORMAL"


@attrs.define()
class FullRealm:
    id: int
    remote_subscription_id: str
    owner: str
    owner_uuid: str
    name: str
    default_permission: DefaultPermission
    state: State
    days_left: int
    expired: bool
    expired_trial: bool
    grace_period: bool
    world_type: WorldType
    players: None
    max_players: int
    minigame_name: None
    minigame_id: None
    minigame_image: None
    active_slot: int
    slots: None
    member: bool
    club_id: int
    subscription_refresh_status: None
    motd: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "FullRealm":  # sourcery skip: avoid-builtin-shadow
        id = obj.get("id")
        remote_subscription_id = obj.get("remoteSubscriptionId")
        owner = obj.get("owner")
        owner_uuid = obj.get("ownerUUID")
        name = obj.get("name")
        default_permission = DefaultPermission(obj.get("defaultPermission"))
        state = State(obj.get("state"))
        days_left = obj.get("daysLeft")
        expired = obj.get("expired")
        expired_trial = obj.get("expiredTrial")
        grace_period = obj.get("gracePeriod")
        world_type = WorldType(obj.get("worldType"))
        players = obj.get("players")
        max_players = obj.get("maxPlayers")
        minigame_name = obj.get("minigameName")
        minigame_id = obj.get("minigameId")
        minigame_image = obj.get("minigameImage")
        active_slot = obj.get("activeSlot")
        slots = obj.get("slots")
        member = obj.get("member")
        club_id = obj.get("clubId")
        subscription_refresh_status = obj.get("subscriptionRefreshStatus")
        motd = obj.get("motd")
        return FullRealm(
            id,
            remote_subscription_id,
            owner,
            owner_uuid,
            name,
            default_permission,
            state,
            days_left,
            expired,
            expired_trial,
            grace_period,
            world_type,
            players,
            max_players,
            minigame_name,
            minigame_id,
            minigame_image,
            active_slot,
            slots,
            member,
            club_id,
            subscription_refresh_status,
            motd,
        )


@attrs.define()
class FullWorlds:
    servers: List[FullRealm]

    @staticmethod
    def from_dict(obj: Any) -> "FullWorlds":
        servers = from_list(FullRealm.from_dict, obj.get("servers"))
        return FullWorlds(servers)


class Permission(Enum):
    MEMBER = "MEMBER"
    OPERATOR = "OPERATOR"
    VISITOR = "VISITOR"


@attrs.define()
class Player:
    uuid: str
    name: None
    operator: bool
    accepted: bool
    online: bool
    permission: Permission

    @staticmethod
    def from_dict(obj: Any) -> "Player":
        uuid = obj.get("uuid")
        name = obj.get("name")
        operator = obj.get("operator")
        accepted = obj.get("accepted")
        online = obj.get("online")
        permission = Permission(obj.get("permission"))
        return Player(uuid, name, operator, accepted, online, permission)


@attrs.define()
class PartialRealm:
    id: int
    players: List[Player]
    full: bool

    @staticmethod
    def from_dict(obj: Any) -> "PartialRealm":
        # sourcery skip: avoid-builtin-shadow
        id = obj.get("id")
        players = from_list(Player.from_dict, obj.get("players"))
        full = obj.get("full")
        return PartialRealm(id, players, full)


@attrs.define()
class ActivityList:
    servers: List[PartialRealm]

    @staticmethod
    def from_dict(obj: Any) -> "ActivityList":
        servers = from_list(PartialRealm.from_dict, obj.get("servers"))
        return ActivityList(servers)


class RealmsAPIException(Exception):
    def __init__(self, resp: aiohttp.ClientResponse, error: Exception):
        self.resp = resp
        self.error = error

        super().__init__(
            "An error occured when trying to access this resource: code"
            f" {resp.status}.\nError: {error}"
        )


@attrs.define()
class RealmsAPI:
    session: aiohttp.ClientSession = attrs.field()
    auth_mgr: AuthenticationManager = attrs.field(init=False)

    def __attrs_post_init__(self):
        self.auth_mgr = AuthenticationManager(
            self.session,
            os.environ["XBOX_CLIENT_ID"],
            os.environ["XBOX_CLIENT_SECRET"],
            "",
        )
        self.auth_mgr.oauth = OAuth2TokenResponse.parse_file(
            os.environ["XAPI_TOKENS_LOCATION"]
        )
        asyncio.create_task(self.refresh_tokens())

    @property
    def HEADERS(self):
        return {
            "Client-Version": utils.MC_VERSION,
            "User-Agent": "MCPE/UWP",
            "Authorization": self.auth_mgr.xsts_token.authorization_header_value,
        }

    async def refresh_tokens(self):
        """Refresh all tokens."""
        if not (self.auth_mgr.oauth and self.auth_mgr.oauth.is_valid()):
            self.auth_mgr.oauth = await self.auth_mgr.refresh_oauth_token()
        if not (self.auth_mgr.user_token and self.auth_mgr.user_token.is_valid()):
            self.auth_mgr.user_token = await self.auth_mgr.request_user_token()
        if not (self.auth_mgr.xsts_token and self.auth_mgr.xsts_token.is_valid()):
            self.auth_mgr.xsts_token = await self.auth_mgr.request_xsts_token(
                relying_party=utils.REALMS_API_URL
            )

    async def request(self, method: str, url: str, data: typing.Optional[dict] = None):
        # refresh token as needed
        await self.refresh_tokens()

        async with self.session.request(
            method, f"{utils.REALMS_API_URL}{url}", headers=self.HEADERS, data=data
        ) as resp:
            try:
                resp.raise_for_status()
                return await resp.json(loads=orjson.loads)
            except Exception as e:
                raise RealmsAPIException(resp, e)

    async def get(self, url: str, data: typing.Optional[dict] = None):
        return await self.request("GET", url, data=data)

    async def post(self, url: str, data: typing.Optional[dict] = None):
        return await self.request("POST", url, data=data)

    async def join_realm_from_code(self, code: str):
        return FullRealm.from_dict(await self.post(f"invites/v1/link/accept/{code}"))

    async def fetch_realms(self):
        return FullWorlds.from_dict(await self.get("worlds"))

    async def fetch_activities(self):
        return ActivityList.from_dict(await self.get("activities/live/players"))
